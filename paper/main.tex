\documentclass[crc,english]{programming}
\usepackage[backend=biber]{biblatex}
\addbibresource{refs.bib}
\usepackage{svg}
\svgpath{img}

% Fix broken footnotes
\makeatletter
\renewcommand\@makefntext[1]{\leftskip=0.7em\hskip-0.75em\@makefnmark\hspace{1mm}#1}
\makeatother
\renewcommand{\footnotesize}{\small}
\setlength{\footnotesep}{3mm}

\definecolor{darkblue}{rgb}{0,0,0.5}
\definecolor{darkgreen}{rgb}{0,0.3,0}
\definecolor{darkpink}{rgb}{0.4,0,0.3}
\definecolor{graygreen}{rgb}{0.3,0.5,0.3}
\definecolor{grayblue}{rgb}{0.2,0.2,0.6}
\definecolor{grayred}{rgb}{0.5,0.2,0.2}

\lstset{
  backgroundcolor=\color{white},     % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  % identifierstyle=\color{red},
  basicstyle=\normalsize\ttfamily,      % the size of the fonts that are used for the code
  breakatwhitespace=false,              % sets if automatic breaks should only happen at whitespace
  breaklines=false,                     % sets automatic line breaking
  captionpos=b,                         % sets the caption-position to bottom
  abovecaptionskip=-3 mm,
  commentstyle=\itshape\color{graygreen}, % comment style
  % escapeinside={(:}{:)},             % if you want to add LaTeX within your code
  escapechar={!},
  % extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  % firstnumber=1000,                % start line enumeration with line 1000
  % frame=tb,                        % adds a frame around the code
  % keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{darkblue},     % keyword style
  language=Haskell,                  % the language of the code
  morekeywords={ Set, Tree, Leaf, Node, Applicative, fmap, liftA2, bimap, foldMap
               , traverse, mappend, pure, Foldable, Traversable, zero, one
               , Semiring, Semigroup, NonEmpty, sconcat, TSet,
               , SimplicialSet, TSimplicialSet, Graph, TGraph, LGraph
               , Map, IsString, fromString },
  deletekeywords={instance, data, where, class, filter, type, insert, delete, union, map},      % if you want to delete keywords from the given language
  emph={data, class, instance, where, type},
  emphstyle=\color{darkpink},
  numbers=none,                      % where to put the line-numbers; possible values are (none, left, right)
  % numbersep=5pt,                   % how far the line-numbers are from the code
  % numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  % rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  % showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  % showstringspaces=false,          % underline spaces within strings only
  % showtabs=false,                  % show tabs within strings adding particular underscores
  % stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{grayred},     % string literal style
  % tabsize=2,                       % sets default tabsize to 2 spaces
  % title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  xleftmargin=10pt,
  aboveskip=8pt,
  belowskip=4pt
}

\newcommand{\code}[1]{\lstinline[mathescape]|#1|}
\newcommand{\hcode}[1]{{\color{darkblue} \lstinline[keywordstyle={}]|#1|}} % h for "highlighted"
\newcommand{\h}[1]{{\itshape\color{grayblue}#1}} % h for "highlighted"
\newcommand{\n}[1]{{\itshape\color{graygreen}#1}} % n for "normal"
\newcommand{\up}[1]{{\itshape\color{graygreen}\textsuperscript{#1}}}
\newcommand{\hadd}{{\large\color{darkblue} $\oplus$}}
\newcommand{\hmul}{{\large\color{darkblue} $\otimes$}}
\newcommand{\hdia}{\,\text{\raisebox{-0.2mm}{\Large\color{darkblue} $\diamond$}}\,}
\newcommand{\harr}{\,\text{\color{darkblue} $\rightarrow$}\,}

\newcommand{\add}{\text{\raisebox{-0.1mm}{\large $\oplus$}}}
\newcommand{\mul}{\text{\raisebox{-0.1mm}{\large $\otimes$}}}
\newcommand{\zero}{\raisebox{-0.2mm}{\textcircled{\textsf{0}}}\xspace}
\newcommand{\one}{\raisebox{-0.2mm}{\textcircled{\textsf{\hspace{-0.2mm}1}}}\xspace}
\newcommand{\two}{\raisebox{-0.2mm}{\textcircled{2}}\xspace}
\newcommand{\dia}{\,\text{\raisebox{-0.3mm}{\Large $\diamond$}}\,}
\newcommand{\arr}{\,\text{$\rightarrow$}\,}
\newcommand{\ldia}{\text{\raisebox{-0.3mm}{\Large $\diamond$}}}

%%% The following is specific to Programming Journal, Volume 6, Issue 3 and the paper
%%% 'United Monoids: Finding Simplicial Sets and Labelled Algebraic Graphs in Trees'
%%% by Andrey Mokhov.
%%%
\paperdetails{
  submitted=2021-10-01,
  published=2022-02-15,
  year=2022,
  volume=6,
  issue=3,
  articlenumber=12,
}
\begin{document}

\paperdetails{
    perspective=sciencetheoretical,
    area={Functional Data Structures}
}

\title{United Monoids}
\subtitle{Finding Simplicial Sets and Labelled Algebraic Graphs in Trees}
\author[~]{Andrey Mokhov}
\authorinfo{is a software engineer at Jane Street London,
  and a visiting fellow at Newcastle University, UK. His
  research interests are in applying abstract mathematics and
  functional programming to solving large-scale engineering
  problems.
  \begin{description}
    \item[email:] \email{andrey.mokhov@ncl.ac.uk}
  \end{description}}
\affiliation[~]{\hspace{-5.3mm}Jane Street, London, UK}
\affiliation[~]{\hspace{-5.3mm}Newcastle University, Newcastle upon Tyne, UK}

\keywords{algebra, graphs, functional programming}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002950.10003624.10003633</concept_id>
<concept_desc>Mathematics of computing~Graph theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Mathematics of computing~Graph theory}

\maketitle

\begin{abstract}
% Below is a shorter version of the abstract, which I prefer. Alas, it does not
% conform to the journal guidelines.
%
% =================================
% This paper demonstrates how a simple inductive data type can be used as a
% language for describing and manipulating various combinatorial graph-like
% structures. By changing the rules of interpretation of the language, we will
% obtain sets, preorders, edge-labelled graphs, and simplicial sets.
%
% As a theoretical contribution, the paper presents united monoids, an algebraic
% structure that turns out to be a common ground for the graph-like structures
% discussed in the paper.
% =================================

% Guidelines specify the following structure:
%
% Context: What is the broad context of the work? What is the importance of the
% general research area?
%
% Inquiry: What problem or question does the paper address? How has this problem
% or question been addressed by others (if at all)?
%
% Approach: What was done that unveiled new knowledge?
%
% Knowledge: What new facts were uncovered? If the research was not results
% oriented, what new capabilities are enabled by the work?
%
% Grounding: What argument, feasibility proof, artifacts, or results and
% evaluation support this work?
%
% Importance: Why does this work matter?

Graphs and various graph-like combinatorial structures, such as
preorders and hypergraphs, are ubiquitous in programming. This paper focuses on
representing graphs in a purely functional programming language like Haskell.
There are several existing approaches; one of the most recently developed ones
is the ``algebraic graphs'' approach (2017). It uses an algebraic data type to
represent graphs and has attracted users, including from industry, due to its
emphasis on equational reasoning and making a common class of bugs impossible
by eliminating internal invariants.

The previous formulation of algebraic graphs did not support edge labels, which
was a serious practical limitation. In this paper, we redesign the main
algebraic data type and remove this limitation. We follow a fairly standard
approach of parameterising a data structure with a semiring of edge labels. The
new formulation is both more general and simpler: the two operations for
composing graphs used in the previous work can now be obtained from a single
operation by fixing the semiring parameter to zero and one, respectively.

By instantiating the new data type with different semirings, and working out
laws for interpreting the resulting expression trees, we discover an unusual
algebraic structure, which we call ``united monoids'', that
is, a pair of monoids whose unit elements coincide. We believe that it is worth
studying united monoids in their full generality, going beyond the graphs which
prompted their discovery. To that end, we characterise united monoids with a
minimal set of axioms, prove a few basic theorems, and discuss several notable
examples.

We validate the presented approach by implementing it in the
open-source \textsf{algebraic-graphs} library. Our theoretical contributions
are supported by proofs that are included in the paper and have also
been machine-checked in Agda. By extending algebraic graphs with support for
edge labels, we make them suitable for a much larger class of possible
applications. By studying united monoids, we provide a theoretical foundation
for further research in this area.
\end{abstract}

\section{Introduction}
\vspace{-1mm}

Graphs and various graph-like combinatorial structures are ubiquitous in
programming. There are numerous approaches to representing graphs, from good old
adjacency matrices~\cite{cormen2009introduction} to categorical graph
algebras~\cite{2010_selinger_survey}. This paper introduces a new purely
functional graph representation, building on the earlier work on
\emph{algebraic graphs}~\cite{mokhov_alga}. The new representation is based on
elementary foundations (trees and semirings), and provides an expressive
language for modelling graph-like structures.

The following data type of binary trees with \hcode{a}-labelled leaves and
\hcode{s}-labelled internal nodes will be the main protagonist of our
story\footnote{
    We will use Haskell throughout this paper but the presented ideas
    are not Haskell-specific and can be readily translated to other languages.
}:

\begin{lstlisting}
data Tree s a = Leaf a | Node s (Tree s a) (Tree s a)
\end{lstlisting}

\noindent
In this paper we are going to interpret such trees in a few different ways. To
do that, we will \emph{fold} them~\cite{gibbons_folds} by specifying different
pairs of functions \hcode{leaf} and \hcode{node}, which will give meanings (of
type \hcode{m}) to the leaves and internal nodes, respectively:

\begin{lstlisting}
fold :: (a -> m) -> (s -> m -> m -> m) -> Tree s a -> m
fold leaf node = meaning
  where
    meaning (Leaf a) = leaf a
    meaning (Node s x y) = node s (meaning x) (meaning y)
\end{lstlisting}

\noindent
For example, to compute the \emph{size} of a tree, i.e., the number of leaves in
it, we can fold the tree into an \code{Int} as follows.

\begin{lstlisting}
size :: Tree s a -> Int
size = fold (\a -> 1) (\s x y -> x + y)
\end{lstlisting}

\noindent
Here we ignore the labels of leaves and internal nodes: every leaf is
interpreted as~$1$, and every internal node simply adds up the sizes of its
children. In the rest of the paper, we will study more interesting ways to fold
trees. In particular, we will see how the very same data type can serve us when
working with sets, preorders, various flavours of graphs, and simplicial sets.
More specifically, our contributions are as follows.

\begin{itemize}
  \item We extend \emph{algebraic graphs}~\cite{mokhov_alga} to support edge
  labels (\S\ref{sec-labelled}), and also simplify their inductive definition
  from four to just two constructors (the \code{Tree} data type,
  \S\ref{sec-tree}).

  \item To demonstrate the flexibility of the new approach, we show how it can
  be used to work with a variety of combinatorial structures, including
  simplicial sets and preorders (\S\ref{sec-set}-\S\ref{sec-preorder}). All of
  these seemingly different structures turn out to be just different
  interpretations of the same underlying language of trees.

  \item We introduce \emph{united monoids} as an algebraic structure that
  captures the essence of the various studied interpretations of trees
  (\S\ref{sec-united}). We also characterise united monoids with a minimal set
  of axioms and prove a few basic theorems.
\end{itemize}

\noindent
We review related work in~\S\ref{sec-related-work}.

\section{Trees}\label{sec-tree}

In this section we study the \hcode{Tree s a} data type in more detail. An
experienced functional programmer will find the data type and various
associated functions fairly standard, so this section can be skipped after
glancing through the definitions in Listings~\ref{lst-tree-std}
and~\ref{lst-tree}.

Throughout the paper, leaves of our trees will represent \emph{elements} (of
sets and preorders) or \emph{vertices} (of simplicial sets and graphs). We will
treat their labels~\hcode{a} as abstract, apart from the occasional requirement
of \hcode{Eq a} or \hcode{Ord a}, e.g., to be able to collect leaves into a set.
Internal nodes, on the other hand, will represent various kinds of
\emph{connectivity}, and we will require that their labels~\hcode{s} come from
a semiring~\cite{1999_semirings_golan}.

A \emph{semiring} is an algebraic structure that generalises arithmetic: it's a
set equipped with associative\footnote{
    An operation $\bullet$ is \emph{associative} if
    $(a \bullet b) \bullet c = a \bullet (b \bullet c)$. Associativity is
    convenient both for humans (making parentheses unnecessary) and machines
    (allowing large expressions to be efficiently processed by partitioning them
    into smaller subexpressions as necessary).
}
operations of \emph{addition}~$\add$ and \emph{multiplication}~$\mul$, whose
units\footnote{
    An element $e$ is the \emph{unit} (or the \emph{identity element}) of an
    operation $\bullet$ if $e \bullet a = a \bullet e = a$.
}
are \emph{zero}~$\text{\zero}$ and \emph{one}~$\text{\one}$, respectively.
Semirings give us a basic language for connectivity:

\vspace{-1mm}
\begin{itemize}
  \item The lack of connectivity is denoted by~\zero. For instance, zero network
        bandwidth.
  \item Addition~$\add$ is a commutative\footnote{
            An operation $\bullet$ is \emph{commutative} if
            $a \bullet b = b \bullet a$.
        } operation for combining connections in \emph{parallel}; e.g.,
        selecting a link with the \emph{maximum} bandwidth from available
        alternatives.
  \item Multiplication~$\mul$ combines connections in \emph{sequence}.
        Continuing the example, to compute the bandwidth of a route, we take the
        \emph{minimum} over all links that need to be traversed. Multiplication
        distributes\footnote{
            \emph{Distributivity} of $\otimes$ over $\oplus$ means
            $a \otimes (b \oplus c) = (a \otimes b) \oplus (a \otimes c)$ and
            $(a \oplus b) \otimes c = (a \otimes c) \oplus (b \otimes c)$.
        } over addition and has \zero as its zero\footnote{
            An element $z$ is the \emph{zero} (or the
            \emph{annihilating element}) of an operation $\bullet$ if
            $z \bullet a = a \bullet z = z$.
        }.
  \item Finally, \one denotes either a unit of connectivity or infinite
        connectivity, depending on a specific semiring. In the bandwidth
        semiring, we have $\text{\one} = \infty$.
\end{itemize}

\noindent
We first turn our attention to trees whose internal nodes are labelled
with~\zero, i.e., whose leaves are \emph{disconnected}. For example, the trees
shown below correspond to expressions \code{"a"}, \code{"b" $\,\hdia\,$ "b"},
\code{("a" $\,\hdia\,$ "b") $\,\hdia\,$ "c"} and
\code{"a" $\,\hdia\,$ ("b" $\,\hdia\,$ "c")}, where the operator \code{$\dia$}
comes from the \code{Semigroup (Tree s a)} instance, and string literals are
desugared into leaves using the \code{OverloadedStrings} extension
(see Listing~\ref{lst-tree-std}).

\vspace{2.2mm}
\hfill\includesvg[scale=0.28]{tree-examples}\hfill
\vspace{2.3mm}

\noindent
A \emph{semigroup} is a set with an associative operation. It may seem worrying
that our \code{Semigroup} instance yields different trees for left- and
right-associated expressions, as in the last two examples. To resolve this, we
make the \code{Tree} data type abstract and require all uses of \hcode{fold} to
respect the associativity when interpreting trees. Concretely, the
\hcode{fold}'s argument \hcode{node} must yield associative functions for all
\hcode{s}, including \hcode{s = zero}.

\begin{lstlisting}[float,label=lst-tree-std,xleftmargin=0pt,caption={
    The \code{Tree} data type and instances of various standard Haskell type classes.
}]
!\hrulefill!
data Tree s a = Leaf a | Node s (Tree s a) (Tree s a)

fold :: (a -> m) -> (s -> m -> m -> m) -> Tree s a -> m -- Note: !\h{node s}! must be associative
fold leaf node = meaning
  where
    meaning (Leaf a) = leaf a
    meaning (Node s x y) = node s (meaning x) (meaning y)

class Semiring s where -- In this paper, !\h{s}! in !\h{Tree s a}! is always a !\h{Semiring}!
    zero :: s !\hspace{14.9mm}!-- Unit of !\hadd!, zero of !\hmul!
    (!\hadd!) !\hspace{1.55mm}!:: s -> s -> s !\hspace{1.4mm}!-- Associative, commutative
    one !\hspace{0.75mm}!:: s !\hspace{14.9mm}!-- Unit of !\hmul!
    (!\hmul!) !\hspace{1.55mm}!:: s -> s -> s !\hspace{1.4mm}!-- Associative, distributes over !\hadd!

instance Semiring s => Semigroup (Tree s a) where
    (!\hdia!) :: Tree s a -> Tree s a -> Tree s a
    (!\hdia!) = Node zero -- All tree interpretations must respect the associativity of !\hdia!

instance Functor (Tree s) where
    fmap :: (a -> b) -> Tree s a -> Tree s b -- Apply a function !\h{a -> b}! to every leaf !\h{a}!
    fmap f = fold (Leaf . f) Node

instance Applicative (Tree s) where
    pure :: a -> Tree s a -- Create a !\n{``}!trivial!\n{''}! tree containing a single leaf
    pure = Leaf
    (<*>) :: Tree s (a -> b) -> Tree s a -> Tree s b -- Graft the 2!\up{nd}! tree on every leaf of the 1!\up{st}!
    (<*>) = ap !\hspace{52.6mm}!-- Standard implementation via Monad

instance Monad (Tree s) where
    (>>=) :: Tree s a -> (a -> Tree s b) -> Tree s b -- Graft a tree !\h{f a}! on every leaf !\h{a}!
    x >>= f = fold f Node x

instance Foldable (Tree s) where
    foldr :: (a -> b -> b) -> b -> Tree s a -> b -- Fold leaves from right to left
    foldr f b tree = fold f (const (.)) tree b

instance Traversable (Tree s) where
    traverse :: Applicative f => (a -> f b) -> Tree s a -> f (Tree s b) -- Effectful variant of !\h{fmap}!
    traverse f = fold (fmap Leaf . f) (liftA2 . Node)

instance IsString a => IsString (Tree s a) where -- This makes !\h{"a"}! a shortcut for !\h{Leaf "a"}!
    fromString = Leaf . fromString
!\rule[2mm]{\textwidth}{0.4pt}!
\end{lstlisting}

\begin{lstlisting}[float,label=lst-tree,xleftmargin=0pt,belowskip=-2mm,caption={
    A basic API for constructing and manipulating trees. We use the standard
    module \code{Data.L}\code{ist.N}\code{onEmpty} for representing non-empty
    lists, and \code{Data.S}\code{et} for sets.}]
!\rule[2mm]{\textwidth}{0.4pt}!
!\vspace{-7mm}!
leaf :: a -> Tree s a -- A tree with a single leaf
leaf = Leaf

leaves :: Semiring s => NonEmpty a -> Tree s a -- A tree of !\n{``}!disconnected!\n{''}! leaves
leaves = sconcat . NonEmpty.map Leaf -- Via !\h{Semigroup}!'s !\h{sconcat}!

node :: s -> Tree s a -> Tree s a -> Tree s a -- Combine two trees into an !\h{s}!-labelled node
node = Node

size :: Tree s a -> Int -- The number of leaves in a tree
size = length -- Via !\h{Foldable}!

leafSet :: Ord a => Tree s a -> Set a -- The set of leaves of a tree
leafSet = fold Set.singleton (const Set.union)

hasLeaf :: Eq a => a -> Tree s a -> Bool -- Test if a tree contains a leaf !\h{a}!
hasLeaf = elem -- Via !\h{Foldable}!

prune :: Tree s (Maybe a) -> Maybe (Tree s a) -- Prune all leaves labelled with !\h{Nothing}!
prune = sequence -- Via !\h{Traversable}!

filter :: (a -> Bool) -> Tree s a -> Maybe (Tree s a) -- Prune all leaves !\h{a}! with !\h{p a = False}!
filter p = traverse (\a -> if p a then Just a else Nothing) -- Via !\h{Traversable}!
!\rule[2mm]{\textwidth}{0.4pt}!
\end{lstlisting}

\noindent
It is sometimes necessary to be able to express the \emph{empty tree}. To do
that, we simply wrap the \hcode{Tree} data type into \hcode{Maybe}. This is
illustrated by the function \hcode{prune} (Listing~\ref{lst-tree}), which prunes
all leaves labelled with \hcode{Nothing} and returns a possibly empty tree as a
result. By combining the empty tree and the operation \dia, we can extend our
type of trees from a semigroup to a \emph{monoid}, i.e., a semigroup with a unit
element.

When tree interpretations respect the associativity of \dia, \zero-labelled
trees become isomorphic to non-empty lists. This is evidenced by the functions
\hcode{toList} (provided by the \hcode{Foldable} instance in
Listing~\ref{lst-tree-std}) and \hcode{leaves} (Listing~\ref{lst-tree}). In the
subsequent sections, we will study data structures obtained by instantiating
\hcode{Tree s a} with different semirings~\hcode{s}, and by adding more
requirements (on top of associativity) to tree interpretations.

\section{Sets}\label{sec-set}

In this section we instantiate \hcode{Tree s a} with the \emph{trivial semiring}
\hcode{s = ()} where $\zero = \one = \text{\hcode{()}}$:

\begin{lstlisting}
type TSet a = Tree () a -- We prepend !\h{T}! to avoid a name clash with the standard !\h{Set}!
\end{lstlisting}

\noindent
As hinted by the type synonym's name, we will interpret values \hcode{TSet a} as
(non-empty) sets; to get a standard \hcode{Set a} from a \hcode{TSet a}, we can
simply reuse \hcode{leafSet} from Listing~\ref{lst-tree}.

\begin{lstlisting}[label=lst-set,xleftmargin=0pt,belowskip=7pt,caption={
    Implementing a part of the standard \code{Data.S}\code{et} API with
    \hcode{TSet}.
}]
!\rule[2mm]{\textwidth}{0.4pt}!
!\vspace{-7mm}!
type TSet a = Tree () a -- Sets are trees with !\h{()}!-labelled internal nodes

instance Semiring () where -- The trivial semiring with !\h{zero = one = ()}!
    zero !\hspace{2.55mm}!= ()
    () !\add! () = ()
    one !\hspace{3.55mm}!= ()
    () !\mul! () = ()

singleton :: a -> TSet a !\hspace{32.18mm}\vrule\hspace{8mm}!insert :: a -> TSet a -> TSet a
singleton = Tree.leaf    !\hspace{35.1mm}\vrule\hspace{8mm}!insert = (!\hdia!) . singleton -- Via !\h{Semigroup}!

delete :: Eq a => a -> TSet a -> Maybe (TSet a) -- The empty set is represented by !\h{Nothing}!
delete a = Tree.filter (/= a)

member :: Eq a => a -> TSet a -> Bool !\hspace{9.1mm}\vrule\hspace{8mm}!union :: TSet a -> TSet a -> TSet a
member = Tree.hasLeaf                 !\hspace{30.33mm}\vrule\hspace{8mm}!union = (!\hdia!) -- Via !\h{Semigroup}!

size :: Ord a => TSet a -> Int
size = Set.size . leafSet -- We can't use !\h{Tree.size}! because it uses a non-idempotent !\h{fold}!

cartesianProduct :: TSet a -> TSet b -> TSet (a, b)
cartesianProduct = liftA2 (,) -- Via !\h{Applicative}!

filter :: (a -> Bool) -> TSet a -> Maybe (TSet a) -- The result can be empty
filter = Tree.filter

map :: (a -> b) -> TSet a -> TSet b
map = fmap -- Via !\h{Functor}!
!\rule[2mm]{\textwidth}{0.4pt}!
\end{lstlisting}

\noindent
Listing~\ref{lst-set} shows how to implement a part of the standard set API by
reusing the more general \hcode{Tree}-manipulating functions defined earlier
in~\S\ref{sec-tree}.

In addition to associativity, the set interpretation of trees puts two new
requirements on every call site of \hcode{fold leaf node}\footnote{
    Haskell's type system isn't powerful enough to check such requirements, so
    we should use \hcode{fold} with care. A dependently typed language, such as
    Agda~\cite{2007_norell_agda}, could help us here.
}:

\begin{itemize}
    \item $\text{\hcode{node zero}}~a~b = \text{\hcode{node zero}}~b~a$, i.e.,
          commutativity of \zero-labelled nodes;
    \item $\text{\hcode{node zero}}~a~a = a$, i.e.,
    idempotence\footnote{
         An operation $\bullet$ is \emph{idempotent} if $a \bullet a = a$.
    } of \zero-labelled nodes.
\end{itemize}

\noindent
Therefore we can't use \hcode{Tree.}\code{size} in the implementation of
\hcode{TSet.}\code{size} in Listing~\ref{lst-set}: \hcode{Tree.}\code{size} uses
integer addition for folding internal nodes, which is not idempotent. And
indeed, \hcode{Tree.}\code{size ("b" $\,\hdia\,$ "b")}$\ =2$ since the tree has
\emph{two leaves}, whereas \hcode{TSet.}\code{size ("b" $\,\hdia\,$ "b")}$\ = 1$
since the set described by the tree has only \emph{one element}.

\section{Simplicial Sets}\label{sec-simplicial-set}
\vspace{-1mm}

Describing plain sets with trees isn't new or particularly exciting. However, we
hope the reader found it instructive to see what happens if we instantiate
\hcode{Tree s a} with the simplest semiring \hcode{s = ()}. This section
continues by trying the next simplest semiring, i.e., the
\emph{Boolean semiring} \hcode{s = Bool}, where $\zero = \text{\code{False}}$,
$\one = \text{\code{True}}$, $\add = \text{\code{(\|\|)}}$ and
$\mul = \text{\code{(&&)}}$.

A \emph{simplicial set}~\cite{friedman_simplicial_sets} is a set of
\emph{simplices} of various dimensions along with their incidence relation.
A \emph{$0$-simplex} is a just a point, or a \emph{vertex}, and will correspond
to a leaf in our trees. A \emph{$1$-simplex} is a pair of connected vertices, or
an \emph{edge}; a \emph{$2$-simplex} is a filled-in \emph{triangle}; a
\emph{$3$-simplex} is a solid \emph{tetrahedron}; and so on. Simplicial sets
model systems that cannot be decomposed into pairwise relationships of their
components. For example, it can be useful to distinguish three truly
concurrent events from three events that are concurrent pairwise but constrained
by shared resources~\cite{rosenblum1989look}, e.g., three people eating
ice-cream with two spoons. The former corresponds to a $2$-simplex, while the
latter -- to a simplicial set with three $1$-simplices (a hollow triangle).

To represent simplices of dimension higher than $0$, we will \emph{connect}
their vertices using \one-labelled internal nodes. The figure below shows the
simplicial sets corresponding to the trees
\code{"a"}, \code{"a" $\,\harr\,$ "b"},
\code{("a" $\,\harr\,$ "b") $\,\harr\,$ "c"} and
\code{("a" $\,\hdia\,$ "b") $\,\harr\,$ "c"}, where the operator \code{$\harr$}
is defined as \hcode{x}~\code{$\harr$}~\hcode{y}~\code{=}~\hcode{node one x y}
(see Listing~\ref{lst-simplicial-set}).

\vspace{2.5mm}
\hfill\hspace{-4mm}\includesvg[scale=0.28]{simplicial-set-examples}\hfill
\vspace{2.5mm}

\noindent
Note the difference between the two last examples: by changing the label of one
of the nodes from \one to \zero, we break the corresponding connection,
and as a result, a $2$-simplex (triangle $\textit{abc}$) falls apart into
one-dimensional simplices (edges $\textit{ac}$~and~$\textit{bc}$).

When working with simplicial sets, we will extend the set of requirements on
interpreting trees by adding the \emph{containment} (see~\S\ref{sec-united}) and
distributivity laws:

\vspace{-1mm}\begin{itemize}
    \item Associativity, inherited from~\S\ref{sec-tree}:

          \vspace{0.5mm}\hspace{10mm}$(a \dia b) \dia c = a \dia (b \dia c)$~~and~~$(a \arr b) \arr c = a \arr (b \arr c)$;

    \item Commutativity and idempotence of \dia, inherited from~\S\ref{sec-set}:

          \vspace{0.5mm}\hspace{10mm}$a \dia b = b \dia a$~~and~~$a \dia a = a$;

    \item Containment (\textbf{\color{darkblue}new!}), i.e., every simplex
          \emph{contains} its sub-simplices:

          \vspace{0.5mm}\hspace{10mm}$a \arr b = (a \arr b)\ \dia\ a\ \dia\ b$;

    \item Distributivity (\textbf{\color{darkblue}new!}):

          \vspace{0.5mm}\hspace{10mm}$a \arr (b \dia c) = (a \arr b)\,\dia\,(a \arr c)$~~and~~$(a \dia b) \arr c = (a \arr c)\,\dia\,(b \arr c)$.
\end{itemize}

\noindent
Adding distributivity is motivated by the desire to make the trees
\code{("a" $\,\hdia\,$ "b") $\,\harr\,$ "c"} and
\code{("a" $\,\harr\,$ "c") $\,\hdia\,$ ("b" $\,\harr\,$ "c")} mean the same
simplicial set (the rightmost one above).

\begin{lstlisting}[float,label=lst-simplicial-set,xleftmargin=0pt,caption={
    A basic API for working with simplicial sets represented by trees.
}]
!\rule[2mm]{\textwidth}{0.4pt}!
!\vspace{-7mm}!
type TSimplicialSet a = Tree Bool a -- Simplicial sets are trees over the Boolean semiring

instance Semiring Bool where -- The Boolean semiring with !\h{zero = False}! and !\h{one = True}!
    zero = False
    (!\hadd!) !\hspace{1.5mm}!= (||)
    one !\hspace{0.7mm}!= True
    (!\hmul!) !\hspace{1.5mm}!= (&&)

(!\harr!) :: TSimplicialSet a -> TSimplicialSet a -> TSimplicialSet a
(!\harr!) = Tree.node one

overlay :: TSimplicialSet a -> TSimplicialSet a -> TSimplicialSet a
overlay = (!\hdia!) -- Via !\h{Semigroup}!; recall that !\h{(\hdia) = Tree.node zero}!

connect :: TSimplicialSet a -> TSimplicialSet a -> TSimplicialSet a
connect = (!\harr!)

vertex :: a -> TSimplicialSet a -- 0-simplex
vertex = Tree.leaf

edge :: a -> a -> TSimplicialSet a -- 1-simplex
edge x y = connect (vertex x) (vertex y)

triangle :: a -> a -> a -> TSimplicialSet a !\hspace{6.2mm}!-- 2-simplex
triangle x y z = connect (vertex x) (edge y z) -- Equivalently, !\h{connect (edge x y) (vertex z)}!

simplex :: NonEmpty a -> TSimplicialSet a -- N-simplex
simplex = foldr1 connect . NonEmpty.map vertex -- Via !\h{Foldable}!

hasVertex :: Eq a => a -> TSimplicialSet a -> Bool
hasVertex = Tree.hasLeaf

vertexSet :: Ord a => TSimplicialSet a -> Set a
vertexSet = Tree.leafSet

filter :: (a -> Bool) -> TSimplicialSet a -> Maybe (TSimplicialSet a)
filter = Tree.filter

map :: (a -> b) -> TSimplicialSet a -> TSimplicialSet b -- The so-called !\n{``}!simplicial map!\n{''}!
map = fmap -- Via !\h{Functor}!
!\rule[2mm]{\textwidth}{0.4pt}!
\end{lstlisting}

\noindent
Now that we know the laws for interpreting trees over the Boolean semiring, we
need to choose a target representation for simplicial sets. Alas, there is no
standard \code{Data.SimplicialS}\code{et}, so we need to come up with our own.
Here is a simple candidate:

\begin{lstlisting}
type SimplicialSet a = Set (NonEmpty a)
\end{lstlisting}

\noindent
Here the inner non-empty lists correspond to simplices, with their vertices
listed in the connection order. For example, the simplicial set corresponding to
the tree \code{"a" $\,\harr\,$ "b"} will contain three lists, one for each
contained simplex: \code{[a]}, \code{[b]} and \code{[a,b]}.

Now we can define \hcode{vertex}, \hcode{overlay} and \hcode{connect} to
interpret leaves, \zero-~and \one-labelled nodes, respectively, and
use them to fold a \hcode{Tree Bool a} into a \hcode{SimplicialSet a}:

\begin{lstlisting}
vertex :: a -> SimplicialSet a
vertex = Set.singleton . NonEmpty.singleton
!\vspace{-1mm}!
overlay :: Ord a => SimplicialSet a -> SimplicialSet a -> SimplicialSet a
overlay = Set.union
!\vspace{-1mm}!
connect :: Ord a => SimplicialSet a -> SimplicialSet a -> SimplicialSet a
connect x y =
    Set.unions [x, y, Set.map (uncurry NonEmpty.append) (Set.cartesianProduct x y)]
!\vspace{-1mm}!
toSimplicialSet :: Ord a => Tree Bool a -> SimplicialSet a
toSimplicialSet = fold vertex (\s -> if s then connect else overlay)
\end{lstlisting}

\noindent
Note that \hcode{SimplicialSet} is a rather naive representation for simplicial
sets. In particular, an $n$-simplex contains $O(2^n)$ sub-simplices of
lower dimension, and all of them will be included in the outer \hcode{Set}. One
can improve \hcode{SimplicialSet} by detecting and storing only maximal
simplices or by switching to suffix trees~\cite{weiner_suffix_trees}. Thanks to
the containment requirement, the \hcode{Tree}-based representation of simplicial
sets makes it easy to define an $n$-simplex with a compact $O(n)$-size
expression -- see the function \hcode{simplex} in
Listing~\ref{lst-simplicial-set}.

A key advantage of the \hcode{Tree}-based representation is that it is free from
any internal invariants, i.e., any value of \hcode{Tree Bool a} describes a
(valid) simplicial set. \hcode{SimplicialSet} does not satisfy this property;
for example, the set with two lists \code{[a]} and \code{[a,b]} is not a
simplicial set, because the edge $\textit{ab}$ appears in the set without its
vertex $\textit{b}$.

\vspace{-2mm}
\section{Graphs}\label{sec-graph}

Graphs can be thought of as simplicial sets that contain only $0$-simplices
(vertices) and $1$-simplices (edges). One can therefore represent graphs with a
pair of sets:

\begin{lstlisting}
type Graph a = (Set a, Set (a, a)) -- The classic pair !$(V, E)$! with invariant !$E\subseteq V\times V$!
\end{lstlisting}

\noindent
To interpret trees \hcode{Tree Bool a} as graphs, we need a way to break up
simplices of dimension greater than $1$ into edges. To do that, we impose a new
folding requirement:

\begin{itemize}
    \item Decomposition:
          $a \arr b \arr c = (a \arr b)\,\dia\,(a \arr c)\,\dia\,(b \arr c)$.
\end{itemize}

\noindent
This law is unusual but it is not new: it was introduced as an axiom of
\emph{algebraic graphs} in~\cite{mokhov_alga}. In fact, by adding this
requirement to those used when interpreting simplicial sets
in~\S\ref{sec-simplicial-set}, we get exactly the algebra of non-empty graphs
from~\cite{mokhov_alga}. It is therefore not surprising that we can reuse more
general functions operating on trees and simplicial sets when implementing a
part of the API of algebraic graphs -- see Listing~\ref{lst-graph}, where
\hcode{hasEdge} is the only new function that we needed to implement.

Let us now check that we can fold a \hcode{Tree Bool a} into the corresponding
\hcode{Graph a} while respecting decomposition. The last step will be identical
to the one from~\S\ref{sec-simplicial-set}:

\begin{lstlisting}
toGraph :: Ord a => Tree Bool a -> Graph a
toGraph = fold vertex (\s -> if s then connect else overlay)
\end{lstlisting}

\noindent
All we need to do is adapt \hcode{vertex}, \hcode{overlay} and \hcode{connect}
to ``truncated'' simplicial sets. The truncated variants of \hcode{vertex} and
\hcode{overlay} are straightforward:

\begin{lstlisting}
vertex :: a -> Graph a
vertex a = (Set.singleton a, Set.empty)

overlay :: Ord a => Graph a -> Graph a -> Graph a
overlay (v1, e1) (v2, e2) = (Set.union v1 v2, Set.union e1 e2)
\end{lstlisting}

\noindent
To connect two graphs, we augment their original edges with a Cartesian product
of their vertex sets:

\begin{lstlisting}
connect :: Ord a => Graph a -> Graph a -> Graph a
connect (v1,e1) (v2,e2) = (Set.union!\,!v1!\,!v2, Set.unions!\,![e1,!\,!e2,!\,!Set.cartesianProduct!\,!v1!\,!v2])
\end{lstlisting}

\noindent
It is not obvious that this interpretation respects the decomposition law, so
let us check it. For the vertex set, the law holds because $\cup$ is idempotent:

\vspace{-5mm}
\begin{equation*}
v_1 \cup v_2 \cup v_3 = (v_1 \cup v_2) \cup (v_1 \cup v_3) \cup (v_2 \cup v_3)
\end{equation*}
\vspace{-5mm}

\noindent
As for the edge set, one can mechanically check that both sides of the
decomposition law evaluate to the following expression when
\code{($\hdia$)}~$=$~\hcode{overlay} and \code{($\harr$)}~$=$~\hcode{connect}.

\vspace{-5mm}
\begin{equation*}
e_1 \cup e_2 \cup e_3 \cup (v_1 \times v_2) \cup (v_1 \times v_3) \cup (v_2 \times v_3)
\end{equation*}
\vspace{-5mm}

\subsection{Other Kinds of Graphs}\label{sec-other-graphs}

So far we discussed only directed graphs with no edge labels. One way to support
other kinds of graphs is to strengthen the tree folding requirements.
Specifically:

\begin{itemize}
    \item For \emph{undirected graphs}, $\arr$ must commute for leaves:
    \hcode{leaf}$~a \arr $\hcode{leaf}~$b =~$\hcode{leaf}$~b \arr $\hcode{leaf}~$a$.
    Taken with other requirements, this leads to general commutativity
    $a \arr b = b \arr a$.
    \item For \emph{reflexive graphs}, $\arr$ must have no effect on leaves:
    \hcode{leaf}$~a =~$\hcode{leaf}$~a\,\arr\,$\hcode{leaf}~$a$.
    \item For \emph{bipartite graphs}, $\arr$ must have no effect on leaves
    corresponding to vertices from the same part. That is,
    $\forall (a,b) \in (P \times P) \cup (Q \times Q),\ $\hcode{leaf}$~a\,\dia\,$\hcode{leaf}~$b =~$\hcode{leaf}$~a\,\arr\,$\hcode{leaf}~$b$,
    where $P$~and~$Q$ are the two parts of the bipartite graph.
    \item For \emph{transitively-closed} and \emph{acyclic graphs},
    see~\S\ref{sec-preorder}.
\end{itemize}

\noindent
Another approach to supporting new kinds of graphs is instantiating
\hcode{Tree s a} with other semirings \hcode{s}. In~\S\ref{sec-labelled}, this
will allow us to support \emph{edge-labelled graphs}.

\begin{lstlisting}[float,label=lst-graph,xleftmargin=0pt,caption={
    Implementing a part of the \code{Algebra.G}\code{raph} API~\cite{mokhov_alga}
    with \hcode{Tree Bool a}.
}]
!\rule[2mm]{\textwidth}{0.4pt}!
!\vspace{-7mm}!
type TGraph a = Tree Bool a -- Graphs are trees over the Boolean semiring

vertex :: a -> TGraph a
vertex = SimplicialSet.vertex

edge :: a -> a -> TGraph a
edge = SimplicialSet.edge

vertices :: NonEmpty a -> TGraph a
vertices = Tree.leaves

clique :: NonEmpty a -> TGraph a -- A clique is a set of pairwise connected vertices
clique = SimplicialSet.simplex

overlay :: TGraph a -> TGraph a -> TGraph a
overlay = SimplicialSet.overlay

connect :: TGraph a -> TGraph a -> TGraph a
connect = SimplicialSet.connect

vertexSet :: Ord a => TGraph a -> Set a
vertexSet = SimplicialSet.vertexSet

edgeSet :: Ord a => TGraph a -> Set (a, a)
edgeSet = snd . toGraph

induce :: (a -> Bool) -> TGraph a -> Maybe (TGraph a) -- The result may be empty
induce = Tree.filter

hasVertex :: Eq a => a -> TGraph a -> Bool
hasVertex = SimplicialSet.hasVertex

hasEdge :: Ord a => a -> a -> TGraph a -> Bool
hasEdge x y graph = case induce (\a -> a == x || a == y) graph of
    Nothing -> False
    Just sub -> elem (x,!\,!y) (edgeSet sub) -- Here !\h{sub}! can only contain vertices !\h{x}! and !\h{y}!
!\rule[2mm]{\textwidth}{0.4pt}!
\end{lstlisting}

\section{Preorders and Generalised Transitively-Closed Graphs}\label{sec-preorder}

A \emph{preorder} is a binary relation $\preceq$ that is:

\begin{itemize}
    \item \emph{Reflexive}: $a \preceq a$; and
    \item \emph{Transitive}: $a \preceq b \wedge b \preceq c \Rightarrow a \preceq c$.
\end{itemize}

% In this section we will see how to interpret trees as preorders. We will first
% build on the infrastructure developed for graphs in~\S\ref{sec-graph}, and then
% discuss a generalisation.
\noindent
As mentioned earlier in~\S\ref{sec-other-graphs}, reflexivity can be expressed
as a new law, which requires that connecting a leaf to itself must be redundant:

\begin{itemize}
    \item Reflexivity:
    \hcode{leaf}$~a =~$\hcode{leaf}$~a\,\arr\,$\hcode{leaf}~$a$.
\end{itemize}

\noindent
To ensure that preorder expressions are interpreted
``modulo transitive connections'', we also add the following transitivity law.
It states that adding/removing a transitive connection $a \arr c$ to/from the
tree $a \arr b \dia b \arr c$ must be redundant:

\begin{itemize}
    \item Transitivity: $a \arr b\ \dia\ b \arr c = a \arr b\ \dia\ b \arr c\ \dia\ a \arr c$.
\end{itemize}

% or $a \arr b\ \dia\ b \arr c = a \arr b \arr c$
% Note that the alternative (second) definition makes use of the decomposition
% law.
\noindent
Reading the reflexivity and transitivity laws from left to right, one can think
of them as introducing the preorder terms $a \preceq a$ and $a \preceq c$ under
suitable assumptions.
% Conversely, reading the requirements from right to left corresponds to
% eliminating the terms $a \preceq a$ and $a \preceq c$, or simplifying them away.

We can generalise this approach to trees of type \hcode{Tree s a} where
\hcode{s} is an arbitrary semiring. For clarity, let us adopt the following
shorthand notation:

\vspace{-5mm}
\begin{equation*}
a \xrightarrow{x} b = \text{\hcode{node}}\ x\ a\ b
\end{equation*}
\vspace{-5mm}

\noindent
Then generalised reflexivity and transitivity laws can be expressed as follows.

\begin{itemize}
    \item \emph{Unit}:
    \hcode{leaf}$~a =~$\hcode{leaf}$~a\ \xrightarrow{\ \one\ }\ $\hcode{leaf}~$a$;
    \item \emph{Composition}:
    $a \xrightarrow{x} b\ \dia\ b \xrightarrow{y} c = a \xrightarrow{x} b\ \dia\ b \xrightarrow{y} c\ \dia\ a \xrightarrow{x\,\mul\,y} c$.
\end{itemize}

\noindent
Recalling that semiring's operator $\mul$ composes connectivities in
sequence and that it has \one as the unit, we can refer to these two laws
together as \emph{sequential composition}.

These laws might remind you of the initialisation and relaxation steps used in
various shortest-path finding algorithms. More precisely, in the
\emph{tropical semiring}~\cite{mohri2002semiring}, where $\zero = \infty$,
$\one = 0$, $\add = \min$, and $\mul = +$, the unit law corresponds to
initialising the distance from a vertex to itself to $0$, and composition to
relaxing the distance $a \arr c$ to $x + y$ after finding paths $a \arr b$ and
$b \arr c$ with distances $x$ and $y$, respectively.

Section~\S\ref{sec-labelled} will introduce a few missing tools for working with
generalised edge-labelled graphs. With these tools, and the Floyd-Warshall-Kleene
algorithm~\cite{hopcroft_ullman}\cite{kleene1951representation}, we will be able
to interpret trees over an arbitrary semiring and satisfy the sequential
composition requirements. See an implementation
in~\cite{alga_haskell}.

\subsection{Acyclic Graphs and Partial Orders}\label{sec-acyclic-graphs}
\vspace{-1mm}

The \hcode{Tree} data type cannot rule out cyclic terms like
$a \arr b \dia b \arr a$ at the type level. If these terms are undesirable, we
can turn them all to \emph{errors} by adding two new laws:

\begin{itemize}
    \item \emph{Cycle}:
    \hcode{leaf}$~a\,\arr\,$\hcode{leaf}~$a = \bot$, where $\bot$ is a
    ``cycle error'' value in the target type.
    \item \emph{Zero}: $a \dia \bot = a \arr \bot = \bot \arr a = \bot$.
\end{itemize}

\noindent
These laws plus transitivity ensure that all cyclic terms are equivalent to
$\bot$. This allows us to represent strict partial orders that assert
$\neg (a \prec a)$, and more general concurrency models such as partial order relations labelled with Boolean predicates~\cite{mokhov2009cpog}.

% Switching networks?

\section{Edge-Labelled Graphs}\label{sec-labelled}

% How to decompose?

Equipped with the notation from the previous section~\S\ref{sec-preorder}, we
can use our tree language to describe graphs whose edges are labelled with
values from an arbitrary semiring. For example, the expression
$\text{\code{"a"}} \xrightarrow{\,\one\,} \text{\code{"b"}}\ \dia\ \text{\code{"b"}} \xrightarrow{\,\two\,} \text{\code{"c"}}$
corresponds to the graph below.

\vspace{3mm}
\hfill\includesvg[scale=0.28]{labelled-graph-example}\hfill
\vspace{3mm}

% \noindent
% In Haskell, we can encode this as
% \code{"a"}~\code{-<1>-}~\code{"b"}~\hdia~\code{"b"}~\code{-<2>-}~\code{"c"}
% by defining a pseudo-ternary operator via two auxiliary binary operators
% \code{-<} and \code{>-}:
%
% \begin{lstlisting}
% (-<) :: Tree s a -> s -> (Tree s a, s)  !$\hspace{8mm}\vrule\hspace{8mm}$!(>-) :: (Tree s a, s) -> Tree s a -> Tree s a
% x -< s = (x, s)                         !$\hspace{39.66mm}\vrule\hspace{8mm}$!(x, s) >- y = node s x y
% \end{lstlisting}

\noindent
To give meaning to parallel edges, we introduce the \emph{parallel composition}
law. It is similar to the sequential composition from~\S\ref{sec-preorder}
but concerns \zero and $\add$~instead of~\one~and~$\mul$:

\begin{itemize}
    \item \emph{Unit}:
    \hcode{leaf}$~a =~$\hcode{leaf}$~a\,\xrightarrow{\ \zero\ }\ $\hcode{leaf}~$a$;
    \item \emph{Composition}:
    $a \xrightarrow{x} b\ \dia\ a \xrightarrow{y} b = a \xrightarrow{x\,\add\,y} b$.
\end{itemize}

\noindent
Note that if the semiring is idempotent, i.e., $x\ \add\ x = x$, then these laws
imply general idempotence $a \dia a = a$. Indeed, if $a$ is a leaf, then
idempotence is just the unit law. Otherwise, if $a = p \xrightarrow{x} q$, then
idempotence follows from the composition law:

\vspace{-5mm}
\begin{equation*}
p \xrightarrow{x} q\ \dia\ p \xrightarrow{x} q = p \xrightarrow{x\,\add\,x} q
= p \xrightarrow{x} q.
\end{equation*}
\vspace{-5mm}

\noindent
Furthermore, containment~(\S\ref{sec-simplicial-set}) is also a special case of
parallel composition:

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
a \arr b\ \dia\ a\ \dia\ b & = & a \xrightarrow{\one} b\ \dia\ a \xrightarrow{\zero} b & \text{(definitions of $\arr$, $\dia$ and $\xrightarrow{x}$)}\\
 & = & a \xrightarrow{\one\,\raisebox{0.15mm}{\add}\,\zero} b & \text{(parallel composition)}\\
 & = & a \xrightarrow{\one} b & \text{(unit of $\add$)}\\
 & = & a \arr b & \text{(definitions of $\arr$ and $\xrightarrow{x}$)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
Another tool that we need for interpreting edge-labelled graphs is the
generalised decomposition law, which gives meaning to nested nodes.

\vspace{5mm}
\begin{itemize}
    \item \emph{Decomposition}:

          \vspace{-16.3mm}\begin{equation*}
            \hspace{22.5mm}\begin{cases}
                \ \ (a \xrightarrow{x} b) \xrightarrow{y} c\ =\ a \xrightarrow{x} b\ \dia\ a \xrightarrow{y} c\ \dia\ b \xrightarrow{y} c;\\
                \ \ a \xrightarrow{x} (b \xrightarrow{y} c)\ =\ a \xrightarrow{x} b\ \dia\ a \xrightarrow{x} c\ \dia\ b \xrightarrow{y} c.\\
            \end{cases}
          \end{equation*}
\end{itemize}

\noindent
Interestingly, decomposition subsumes both associativity and distributivity.
Indeed, to derive associativity, we can instantiate both equalities with
$x = y$:

\vspace{-5mm}
\begin{equation*}
(a \xrightarrow{x} b) \xrightarrow{x} c = a \xrightarrow{x} b\ \dia\ a \xrightarrow{x} c\ \dia\ b \xrightarrow{x} c = a \xrightarrow{x} (b \xrightarrow{x} c).
\end{equation*}
\vspace{-5mm}

\noindent
Distributivity then follows from decomposition by setting the inner label to
\zero.

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
(a \dia b) \xrightarrow{x} c &\!\!=\!\!& (a \xrightarrow{\zero} b) \xrightarrow{x} c &\!\!\text{(definitions of $\dia$ and $\xrightarrow{x}$)}\\
 &\!\!=\!\!& a \xrightarrow{\zero} b\ \dia\ a \xrightarrow{x} c\ \dia\ b \xrightarrow{x} c &\!\!\text{(left decomposition)}\\
 &\!\!=\!\!& a\ \dia\ b\ \dia\ a \xrightarrow{x} c\ \dia\ b \xrightarrow{x} c &\!\!\text{(definitions of $\dia$ and $\xrightarrow{x}$)}\\
 &\!\!=\!\!& (a\,\dia\,a\,\xrightarrow{x}\,c)\ \dia\ (b\,\dia\,b\,\xrightarrow{x}\,c) &\!\!\text{(associativity and commutativity of \dia)}\\
 &\!\!=\!\!& a \xrightarrow{x} c\ \dia\ b \xrightarrow{x} c &\!\!\text{(containment)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
To conclude, the complete set of requirements for interpreting edge-labelled
graphs is: commutativity of $\dia$ inherited from sets~(\S\ref{sec-set}),
parallel composition and decomposition.

\newpage
\noindent
With all the folding requirements in place, we can interpret \hcode{Tree}
expressions into the following ``flat'' representation of edge-labelled graphs,
which maps vertices \hcode{a} to a collection of \hcode{s}-labelled outgoing
edges.

% Can't use Set (a, s, a) for edges: parallel composition can't be easily enforced

\begin{lstlisting}
type LGraph s a = Map a (Map a s)
\end{lstlisting}

\noindent
Creating singleton graphs and overlaying graphs is fairly straightforward:

\begin{lstlisting}
vertex :: a -> LGraph s a
vertex x = Map.singleton x Map.empty

overlay :: (Ord a, Semiring s) => LGraph s a -> LGraph s a -> LGraph s a
overlay = Map.unionWith (Map.unionWith (!\h{\hadd}!)) -- Parallel composition
\end{lstlisting}

\noindent
When implementing \hcode{connect}, we come across a subtle issue with
\hcode{LGraph}: it is possible to unintentionally accumulate redundant
\zero-labelled edges in the inner \hcode{Map}. Filtering out these redundant
edges from \hcode{LGraph s a} is an important optimisation when working
with sparse graphs in practice, which is why the code below requires
\hcode{Eq s}\footnote{
    We do not need the full power of \hcode{Eq s} here: we just need to test if
    a given edge label is~\zero. For some types \hcode{s}, testing for \zero is
    much easier than a general equality test; for example, testing if a
    \hcode{Map k v} is empty is trivial but \hcode{Eq (Map k v)} is undecidable
    for some choices of \hcode{v}. To resolve this problem, one can switch to a
    more precise constraint like \hcode{EqZero s}.
}. Note that the \hcode{Tree}-based representation of graphs sidesteps this
issue because \hcode{overlay x y} and \hcode{connect zero x y} are represented
by the same tree \hcode{Node zero x y}.

\begin{lstlisting}
connect :: (Ord a, Semiring s, Eq s) => s -> LGraph s a -> LGraph s a -> LGraph s a
connect s x y
    | s == zero = overlay x y -- Filter out redundant !\h{zero}!-labelled edges
    | otherwise = Map.unionsWith (Map.unionWith (!\h{\hadd}!)) [ x, y, newEdges ]
  where
    outgoing = Map.fromSet (const s) (Map.keysSet y)
    newEdges = Map.fromSet (const outgoing) (Map.keysSet x) -- Decomposition
\end{lstlisting}

\noindent
Finally, we can fold a \hcode{Tree s a} to turn it into the corresponding
\hcode{LGraph s a}:

\begin{lstlisting}
toLGraph :: (Ord a, Semiring s, Eq s) => Tree s a -> LGraph s a
toLGraph = fold vertex connect
\end{lstlisting}

\noindent
It is useful to combine edge-labelled graphs with the sequential composition
law described in the previous section~(\S\ref{sec-preorder}). By computing the
reflexive and transitive closure of an edge-labelled graph, it is possible to
solve a variety of semiring optimisation problems, e.g.,
see~\cite{2013_semirings_dolan}\cite{mohri2002semiring}.
An implementation is available in~\cite{alga_haskell}.

We have now seen how to use trees as a language for describing and manipulating
various kinds of sets and graphs. The next section introduces \emph{united
monoids} that provide a common ground for these seemingly different
combinatorial data structures.

\section{United Monoids}\label{sec-united}

In this section we introduce \emph{united monoids} as an algebraic structure
that turns out to be a common ground for the graph-like structures
discussed earlier in~\S\ref{lst-set}-\S\ref{sec-labelled}.

A \emph{monoid} $(S, \ldia, \varepsilon)$ is a way to express a basic form of
composition in mathematics: any two elements $a$ and $b$ of the set $S$ can be
composed into a new element $a \dia b$ of the same set $S$, and, furthermore,
there is a special element $\varepsilon \in S$, which is the unit element of the
composition, as expressed by the \emph{unit axioms}
$a \dia \varepsilon = \varepsilon \dia a = a$. In words, composing the unit
element with another element does not change the latter.

Monoids often come in pairs: addition and multiplication $(+, \times)$,
disjunction and conjunction $(\vee, \wedge)$, set union and intersection
$(\cup, \cap)$, parallel and sequential composition of processes
$(\text{\code{|}},\ \text{\code{;}})$, etc. Two common ways in which such monoid
pairs can form are called \emph{semirings} and \emph{lattices}. In fact, the
former have played a major role in this paper so far. Below we briefly introduce
the latter.

A \emph{bounded lattice} $(S, \vee, 0, \wedge, 1)$ comprises two monoids, which
are called \emph{join} $(S, \vee, 0)$ and \emph{meet} $(S, \wedge, 1)$. They
operate on the same set, are required to be commutative and idempotent, and
satisfy the following \emph{absorption axioms}: $a \wedge (a \vee b) = a \vee (a \wedge b) = a$. Like semirings, lattices show up very frequently in different application
areas.

\subsection{What if $0=1$?}

What happens when the units of the two monoids in a pair coincide, i.e., when
$0=1$?
In a semiring $(S, \add, \zero, \mul, \one)$, this leads to devastating
consequences. Not only \one becomes equal to \zero, but all other elements of
the semiring become equal to \zero too, as demonstrated below.

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
a & = & \one\ \mul\ a & \text{(unit of $\mul$)}\\
 & = & \zero\ \mul\ a & \text{(we postulate \zero = \one)}\\
 & = & \zero & \text{(zero of $\mul$)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
That is, the semiring is annihilated into a single point \zero, becoming
isomorphic to the trivial semiring \hcode{s = ()}, which we have come across
in~\S\ref{sec-set}.

In a bounded lattice $(S, \vee, 0, \wedge, 1)$, postulating $0 = 1$ leads to the
same catastrophe, albeit in a different manner:

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
a & = & 1\ \wedge\ a & \text{(unit of $\wedge$)}\\
 & = & 1\ \wedge\ (0\  \vee\  a) & \text{(unit of $\vee$)}\\
 & = & 0\ \wedge\ (0\  \vee\  a) & \text{(we postulate 0 = 1)}\\
 & = & 0 & \text{(absorption)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
That is, the lattice is absorbed into a single point $0$.

Postulating $0 = 1$ has so far led to nothing but disappointment. In the
next subsection we find another way of pairing monoids, which does not involve
the axioms of annihilation and absorption, and makes the resulting structure
more interesting.

\subsection{From $0=1$ to Containment Laws and Back}

Consider two monoids $(S, +, 0)$ and $(S, \cdot, 1)$, such that $+$ is
commutative and $\cdot$ distributes over $+$. We call these monoids
\emph{united} if $0 = 1$. To avoid confusion with semirings and lattices, we
will use $\varepsilon$ to denote the unit element of both monoids, that is,
$a + \varepsilon = a \cdot \varepsilon = a$. Note: we will often omit the
operator $\cdot$ and write simply $\textit{ab}$ instead of $a \cdot b$, which is
a common convention. We will further refer to $\varepsilon$ as \emph{empty}, the
operation~$+$ as \emph{overlay}, and the operation~$\cdot$ as \emph{connect}.

What can we tell about united monoids? First of all, it is easy to show that the
monoid $(S, +, \varepsilon)$ is idempotent:

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
a + a & = & a\varepsilon\ +\ a\varepsilon & \text{(unit of $\cdot$)}\\
 & = & a(\varepsilon\ +\ \varepsilon) & \text{(distributivity)}\\
 & = & a\varepsilon & \text{(unit of $+$)}\\
 & = & a & \text{(unit of $\cdot$)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
This means $(S, +, \varepsilon)$ is a commutative idempotent monoid, i.e.,
a \emph{bounded semilattice}.

The next property of is more unusual:
$\textit{ab} = \textit{ab} + a = \textit{ab} + b = \textit{ab} + a + b$. We
call these equalities the \emph{containment laws}: intuitively, when you
connect $a$ and $b$, the constituent parts are contained in the result
$\textit{ab}$. Let us prove containment:

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
\textit{ab}\ +\ a & = & \textit{ab}\ +\ a\varepsilon & \text{(unit of $\cdot$)}\\
 & = & a(b\ +\ \varepsilon) & \text{(distributivity)}\\
 & = & \textit{ab} & \text{(unit of $+$)}\\
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
The two other laws are proved analogously (in fact, they are equivalent to each
other).

Surprisingly, the containment law $\textit{ab} = \textit{ab} + a$ is equivalent
to $0 = 1$, i.e., the latter can also be proved from the former:

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
0 & = & 1\cdot0 & \text{($1$ is the unit of $\cdot$)}\\
 & = & 1\cdot0\ +\ 1 & \text{(containment)}\\
 & = & 0\ +\ 1 & \text{($1$ is the unit of $\cdot$)}\\
 & = & 1 & \text{($0$ is the unit of $+$)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
This means that united monoids can be equivalently characterised by the
containment laws, which makes it possible to also talk about
\emph{united semigroups}. The term ``united semigroup'' may seem somewhat
nonsensical (semigroups have no ``units'' after all), however, note that if they
secretly had unit elements, they would have to coincide.

In the same manner, the containment laws imply that zeroes of the two operations
must be the same. Let $z^{+}$ and $z^{\cdot}$ denote the zeroes of $+$ and
$\cdot$, respectively. Then:

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
z^{+} & = & z^{\cdot}\ +\ z^{+} & \text{($z^{+}$ is the zero of $+$)}\\
 & = & z^{\cdot} \cdot z^{+}\ +\ z^{+} & \text{($z^{\cdot}$ is the zero of $\cdot$)}\\
 & = & z^{\cdot} \cdot z^{+} & \text{(containment)}\\
 & = & z^{\cdot} & \text{($z^{\cdot}$ is the zero of $\cdot$)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
Back in~\ref{sec-acyclic-graphs}, we used zero $\bot$ to model ``cycle errors''.
As we now see, requiring both $a \dia \bot = a$ and
$a \arr \bot = \bot \arr a = \bot$ was unnecessary: we could have picked just
one of these laws and the other one would follow.
For general (i.e., not acyclic) graphs, the fully-connected graph acts as the
zero.

\noindent
Finally, let us prove another unusual property of united monoids: overlay and
connect can have no inverses with respect to $\varepsilon$. That is: if
$a + b = \varepsilon$ or $\textit{ab} = \varepsilon$ then $a = b = \varepsilon$.

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcllcrcll}
a & = & a + \varepsilon & \text{(unit of $+$)} & \vrule & a & = & a + \varepsilon & \text{(unit of $+$)}\\
 & = & a + a + b & \text{(assumption $a + b = \varepsilon$)}& \vrule &  & = & a + \textit{ab} & \text{(assumption $\textit{ab} = \varepsilon$)} \\
 & = & a + b & \text{(idempotence of $+$)}& \vrule & & = & \textit{ab} & \text{(containment)} \\
 & = & \varepsilon & \text{(assumption $a + b = \varepsilon$)}& \vrule & & = & \varepsilon & \text{(assumption $\textit{ab} = \varepsilon$)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
Therefore, it is not possible to extend united monoids to ring- or field-like
structures with inverses.

It is time to look at some examples of united monoids.

\subsection{Examples from This Paper}

The containment laws should have reminded you of simplicial sets since the
latter are closed in terms of containment. For example, a filled-in triangle
contains its edges and vertices, and it cannot appear in a simplicial set
without any of them. This property can be expressed algebraically as:
$\textit{abc} = \textit{abc} + \textit{ab} + \textit{ac} + \textit{bc} + a + b + c$.
Interestingly, this ``3D'' containment law follows from the ``2D'' version for
united monoids:

\vspace{-5mm}
\begin{equation*}
\begin{array}{rcll}
\textit{abc} & = & (\textit{ab} + a + b)c & \text{(containment)}\\
 & = & (\textit{ab})c + \textit{ac} + \textit{bc} & \text{(distributivity)}\\
 & = & (\textit{abc} + \textit{ab} + c) + (\textit{ac} + a) + (\textit{bc} + b) & \text{(containment)}\\
 & = & \textit{abc} + \textit{ab} + \textit{ac} + \textit{bc} + a + b + c & \text{(commutativity)}
\end{array}
\end{equation*}
\vspace{-3mm}

\noindent
We can similarly prove higher-dimensional versions of the containment law; they
all follow from the basic law $\textit{ab} = \textit{ab} + a$, or,
alternatively, from $0 = 1$.

Unlabelled graphs, preorders, and partial orders also satisfy the containment
laws. In this paper, we focused on non-empty structures, which is why we didn't
come across units of the overlay and connect operators. By wrapping trees in
\hcode{Maybe}, as we've done in a few cases, we were essentially augmenting our
structures with the unit \hcode{Nothing}.

It is worth remarking on the two remaining cases: sets and edge-labelled graphs.
When working with sets, we had only one operator \hdia, which was a consequence
of the fact that we used a trivial semiring with \zero~$=$~\one. One can think
of this case as the monoid \hdia~being united with itself.

The case of edge-labelled graphs is more interesting. There we had as many
operations as there were elements in the edge label semiring~\hcode{s}. It turns
out that every monoid $\xrightarrow{x}$ is united with the overlay monoid \hdia.
In other words, edge-labelled graphs form a \emph{semiring of united monoids}.

\subsection{Other Examples}

United monoids also appear when studying the composition of concurrent
processes. As an example, consider Haskell's language extension
\code{ApplicativeDo}~\cite{applicativedo}, which uses a simple cost model for
characterising the execution time of programs that are composed in parallel and
in sequence.

\newpage
\noindent
The cost model comprises two monoids:

\begin{itemize}
    \item $(\mathbb{Z}^{\ge 0}, \max, 0)$: the execution time of programs $a$
    and $b$ composed in parallel is defined to be the maximum of their execution
    times:
    \[
    \text{\hcode{time}}(a\ \text{\code{|}}\ b) = \max(\text{\hcode{time}}(a),\ \text{\hcode{time}}(b))
    \]

    \item $(\mathbb{Z}^{\ge 0}, +, 0)$: the execution time of programs $a$ and
    $b$ composed in sequence is defined to be the sum of their execution times:
    \[
    \text{\hcode{time}}(a\ \text{\code{;}}\ b) = \text{\hcode{time}}(a) + \text{\hcode{time}}(b)
    \]
\end{itemize}

\noindent
Execution times are non-negative, hence both $\max$ and $+$ have unit $0$,
which is the execution time of the \emph{empty program}. It is easy to check
that distributivity ($+$ distributes over $\max$) and containment laws hold.
Note that the resulting algebraic structure is different from the tropical
max-plus semiring $(\mathbb{R}^{-\infty}, \max, -\infty, +, 0)$ commonly used in
scheduling, where the unit of $\max$ is $-\infty$ but the unit of $+$ is $0$.

Interestingly, parallel and sequential composition of programs also forms a
united monoid, where the empty program is the unit. One can therefore call the
cost model function $\text{\hcode{time}}$ a \emph{united monoid
homomorphism}\footnote{
    A \emph{homomorphism} is a structure-preserving map between two algebraic
    structures.
}. Another related example can be found in~\cite{beaumont2017concepts}, where
asynchronous circuit specifications are composed in parallel and in sequence,
using graphs labelled with the semiring of Boolean predicates.

% Naturally ordered
% What about tries?
% Equivalence classes?
% Languages

\section{Related Work}\label{sec-related-work}

This paper continues the research on \emph{algebraic graphs} started
in~\cite{mokhov_alga}. Since their introduction, algebraic graphs have been
implemented in several languages, including Agda~\cite{alga_agda},
F\#~\cite{alga_fsharp}, Haskell~\cite{alga_haskell},
Kotlin~\cite{alga_kotlin}, PureScript~\cite{alga_purescript},
Scala~\cite{alga_scala}, TypeScript~\cite{alga_typescript}, and
R~\cite{alga_r}. Algebraic graphs also found applications in industry, e.g., in
GitHub's static program analysis library
Semantic~\cite{semantic_paper}\cite{semantic_repo}. In this paper we further
distil the essence of the algebraic approach to working with graphs by replacing
the data type

\begin{lstlisting}[basicstyle=\sffamily\smaller]
data Graph a = Empty | Vertex a | Overlay (Graph a) (Graph a) | Connect (Graph a) (Graph a)
\end{lstlisting}

\noindent
with binary trees parameterised by a semiring. We remove the \hcode{Empty}
constructor to make it possible to distinguish non-empty structures at the
type level and also to keep expressions free from redundant empty leaves. By
merging the \hcode{Overlay} and \hcode{Connect} constructors into a single
\hcode{Node} parameterised by a semiring, we get a more general data structure.
This allows us to resolve one of the main limitations of the work
in~\cite{mokhov_alga}, which was the lack of support for edge labels.

Two other popular approaches for representing graphs in functional programming
languages were developed by King and Launchbury~\cite{1995_king_graphs}
(based on adjacency lists, available from the \code{containers} library)
and Erwig~\cite{2001_erwig_inductive} (based on \emph{inductive graphs}, where
graphs can be decomposed into a \emph{context}, i.e., a vertex with its
neighbourhood, and the rest of the graph). These and other classic graph
representations can be obtained from our tree expressions via folding. Note
that, as we remarked in~\S\ref{sec-simplicial-set}, folding a tree expression
into a ``flat'' graph representation too early can be undesirable because of the
loss of compactness and the need to maintain various correctness invariants.

% Add a note to the section on graphs about the invariant

Using semirings as a general framework for solving problems on graphs is, of
course, not new; see, for instance,~\cite{mohri2002semiring}. In the functional
programming community, Dolan's
``Fun with Semirings''~\cite{2013_semirings_dolan} is a
notable example of parameterising matrices with semirings, which motivated the
author of this paper to apply semirings in the context of algebraic graphs. In
a more recent work, Kidney and Wu~\cite{weighted_search} use semirings for
generalising algorithms for weighted search on graphs represented by functions
from vertices to their neighbours.

% Brent's sparks: https://byorgey.wordpress.com/2018/10/01/monoidal-sparks/
% Two monoid products: direct and sparked are monoids with the same identity

Jeremy Gibbons defines operations \hcode{above} and \hcode{beside} for composing
directed acyclic graphs~\cite{1995_gibbons_algebra}. They have the same unit
(the empty graph) but the operation \hcode{beside} is defined only for graphs of
matching types. One can therefore think of \hcode{above} and \hcode{beside} as
\emph{partial united monoids} or \emph{united categories}. Similarly, Santos and
Oliveira~\cite{typed_matrices} show how to compose type-compatible matrices
vertically and horizontally using the operations \hcode{fork} and \hcode{join},
respectively, whose common unit is the empty matrix.

Various flavours of parallel and sequential composition often form united
monoids. In the paper on Concurrent Kleene Algebra~\cite{hoare2011concurrent},
Hoare et al. use the term ``bimonoid'' to refer to such structures (without
investigating them in detail). In category theory, ``bimonoid'' is used for an
unrelated concept (a structure with a monoid and a
comonoid~\cite{porst_bimonoids}). The author of this paper chose to use the term
``united monoids'', because it appears to be unused and is also more specific
compared to ``bimonoid''.

Rivas and Jaskelioff discuss various notions of computation viewing them as
monoids in the category of endofunctors~\cite{rivas_jaskelioff_2017}. Two of
these monoids, namely \hcode{Applicative} and \hcode{Monad}, turn out to have
the same unit \hcode{pure = return}, and they can therefore be considered
\emph{united monoids in the category of endofunctors}. Investigating categorical
equivalents of the presented ideas is an interesting direction of future work.

\acks
I would like to thank everyone who contributed to this research by giving
feedback on earlier versions of this work (particularly,~\cite{mokhov_alga}
and~\cite{united_monoids_blog}), participating in numerous online and
in-person discussions, and last but not least, expressing genuine interest and
encouragement.
Here is a most likely incomplete list (I apologise for any omissions):
Arseniy Alekseyev, Roland Backhouse, Gershom Bazerman, Dave Clarke,
Ulan Degenbaev, Dominique Devriese, Chris Doran, Victor Khomenko, Adithya Kumar,
Dave Long, Anton Lorenzen, Georgy Lukyanov, Alp Mestanogullari, Alexandre Moine,
Andreas Nuyts, Greg Pfeil, Stefan Plantikow, Armando Santos, Danil Sokolov,
Sjoerd Visscher, Leo White and Alex Yakovlev. I am also grateful to the
Programming Journal's Programme Committee for the thorough reviews that helped
me improve the final version of the paper.

\newpage
\printbibliography
\end{document}
